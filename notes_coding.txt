Step 1: Spec-aligned register definitions (offsets + bitfields) for TE/TF/TRS

 Step 2: Read-modify-write helpers for control regs (set/clear/mask fields)

 Step 3: Assertions to validate

 Step 4: Driver-style APIs per component (Encoder/Funnel/RamSink) using only ReadMemory/WriteMemory

 Step 5: Controller/tool abstraction that sequences Configure → Start → Stop → Fetch correctly

 Step 6: Lightweight simulation: generate some trace words + validate fetch works

 

TraceEncoder
    Config():
        1. trTeActive -> TR_TE_CONTROL[0]   = 0 (reset/power down) (other regs inaccessible)
                                            = 1 (active) (write 1 and read back to see if it is 1 then, start config)

        2. trTeEnable -> TR_TE_CONTROL[1]   = 0 (flushes buffer downstream)
                                            = 1 (enable) (MUST Be set last after choosing other settings e.g., trTeInstTracing, trTeInstMode)
        
    Start():
        3. trTeInstTracing -> TR_TE_CONTROL[2]  = 0 
                                                = 1 (start tracing) (MUST be set after trTeEnable; this is the last bit to start pushing traces downstream)

        4. Starts emiting traces

    Stop():


Not modeled:
    - if downstream stream is already full. Set overflow bit.





1. Use shared_ptr for memory management
2. Can lambda functions be used?
3. Should volatile be used? -> not a real hardware so not valid since here we invoke a func call only NOT a h/w reg read 
    static constexpr uint32_t TR_TE_CONTROL = 0x00;
    static constexpr volatile uint32_t TR_TE_CONTROL = 0x00;
4. should we have to pass TR_TE_BASE, TR_FUNNEL_BASE, TR_RAM_SINK_BASE from tci to trace system during initialization in main()?
    - can we directly specify them inside TraceSystem.hardware

5.  keep the clamping function in TraceEncoder?
